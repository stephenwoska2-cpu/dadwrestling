<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wrestling Drill Timer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 30px;
            text-align: center;
        }

        .menu-screen, .setup-screen, .drill-screen {
            width: 100%;
            max-width: 500px;
        }

        .setup-screen, .drill-screen {
            display: none;
            text-align: center;
        }

        .menu-screen {
            text-align: center;
        }

        .mode-btn {
            width: 100%;
            padding: 25px;
            font-size: 1.4rem;
            font-weight: bold;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: transform 0.1s, opacity 0.2s;
        }

        .mode-btn:hover {
            transform: scale(1.02);
        }

        .mode-btn:active {
            transform: scale(0.98);
        }

        .mode-takedowns {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
            color: white;
        }

        .mode-updown {
            background: linear-gradient(135deg, #6c63ff 0%, #5a54d4 100%);
            color: white;
        }

        .back-btn {
            background: transparent;
            border: 2px solid #3a3a6a;
            color: #a0a0a0;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .back-btn:hover {
            border-color: #5a5a9a;
            color: white;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: #a0a0a0;
        }

        .radio-group {
            display: flex;
            gap: 15px;
        }

        .radio-option {
            flex: 1;
            padding: 15px 20px;
            background: #2a2a4a;
            border: 2px solid #3a3a6a;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .radio-option:hover {
            border-color: #5a5a9a;
        }

        .radio-option.selected {
            border-color: #6c63ff;
            background: #3a3a6a;
        }

        .radio-option input {
            display: none;
        }

        .slider-container {
            background: #2a2a4a;
            padding: 20px;
            border-radius: 10px;
        }

        .slider-value {
            font-size: 2rem;
            font-weight: bold;
            color: #6c63ff;
            text-align: center;
            margin-bottom: 15px;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #1a1a2e;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #6c63ff;
            cursor: pointer;
        }

        .start-btn, .control-btn {
            width: 100%;
            padding: 18px;
            font-size: 1.3rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }

        .start-btn {
            background: linear-gradient(135deg, #6c63ff 0%, #5a54d4 100%);
            color: white;
            margin-top: 20px;
        }

        .start-btn:hover {
            transform: scale(1.02);
        }

        .start-btn:active {
            transform: scale(0.98);
        }

        /* Drill Screen Styles */
        .combo-display {
            background: #2a2a4a;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 25px;
        }

        .combo-text {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .combo-progress {
            color: #a0a0a0;
            font-size: 1.1rem;
        }

        .timer-display {
            background: #1a1a2e;
            border-radius: 50%;
            width: 200px;
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 auto 25px;
            border: 4px solid #3a3a6a;
        }

        .timer-value {
            font-size: 4rem;
            font-weight: bold;
        }

        .timer-label {
            font-size: 1rem;
            color: #a0a0a0;
            margin-top: 5px;
        }

        .status-text {
            font-size: 1.5rem;
            margin-bottom: 25px;
            min-height: 2rem;
        }

        .status-setup { color: #ffd93d; }
        .status-set { color: #ff6b6b; }
        .status-wrestling { color: #6bcb77; }
        .status-done { color: #6c63ff; }

        .controls {
            display: flex;
            gap: 15px;
        }

        .control-btn {
            flex: 1;
        }

        .pause-btn {
            background: #ffd93d;
            color: #1a1a2e;
        }

        .stop-btn {
            background: #ff6b6b;
            color: white;
        }

        .control-btn:hover {
            opacity: 0.9;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div class="menu-screen" id="menuScreen">
        <h1>ü§º Wrestling Drill Timer</h1>
        <button class="mode-btn mode-takedowns" id="takedownsBtn">Takedowns</button>
        <button class="mode-btn mode-updown" id="updownBtn">Up / Down</button>
    </div>

    <!-- Setup Screen -->
    <div class="setup-screen" id="setupScreen">
        <button class="back-btn" id="backBtn">‚Üê Back</button>
        <h1 id="setupTitle">ü§º Wrestling Drill Timer</h1>

        <div class="form-group">
            <label>Number of Wrestlers</label>
            <div class="radio-group">
                <label class="radio-option selected" data-value="3">
                    <input type="radio" name="groupSize" value="3" checked>
                    3 Wrestlers
                </label>
                <label class="radio-option" data-value="4">
                    <input type="radio" name="groupSize" value="4">
                    4 Wrestlers
                </label>
            </div>
        </div>

        <div class="form-group">
            <label>Setup Time</label>
            <div class="slider-container">
                <div class="slider-value" id="setupValue">7 seconds</div>
                <input type="range" id="setupSlider" min="5" max="15" value="7" step="1">
            </div>
        </div>

        <div class="form-group">
            <label>Round Duration</label>
            <div class="slider-container">
                <div class="slider-value" id="durationValue">45 seconds</div>
                <input type="range" id="durationSlider" min="30" max="60" value="45" step="5">
            </div>
        </div>

        <button class="start-btn" id="startBtn">Start Drill</button>
    </div>

    <!-- Drill Screen -->
    <div class="drill-screen" id="drillScreen">
        <h1>ü§º Wrestling Drill</h1>

        <div class="combo-display">
            <div class="combo-text" id="comboText">1 up, 2 down</div>
            <div class="combo-progress" id="comboProgress">Round 1 of 6</div>
        </div>

        <div class="timer-display">
            <div class="timer-value" id="timerValue">45</div>
            <div class="timer-label" id="timerLabel">seconds</div>
        </div>

        <div class="status-text" id="statusText"></div>

        <div class="controls">
            <button class="control-btn pause-btn" id="pauseBtn">Pause</button>
            <button class="control-btn stop-btn" id="stopBtn">Stop</button>
        </div>
    </div>

    <script>
        // State
        let drillMode = 'updown'; // 'updown' or 'takedowns'
        let groupSize = 3;
        let setupTime = 7;
        let roundDuration = 45;
        let combinations = [];
        let currentComboIndex = 0;
        let isPaused = false;
        let currentTimer = null;
        let remainingTime = 0;
        let currentPhase = ''; // 'setup', 'set', 'wrestling'

        // Audio context for whistle
        let audioContext = null;

        // DOM Elements
        const menuScreen = document.getElementById('menuScreen');
        const setupScreen = document.getElementById('setupScreen');
        const drillScreen = document.getElementById('drillScreen');
        const setupTitle = document.getElementById('setupTitle');
        const takedownsBtn = document.getElementById('takedownsBtn');
        const updownBtn = document.getElementById('updownBtn');
        const backBtn = document.getElementById('backBtn');
        const setupSlider = document.getElementById('setupSlider');
        const setupValue = document.getElementById('setupValue');
        const durationSlider = document.getElementById('durationSlider');
        const durationValue = document.getElementById('durationValue');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const comboText = document.getElementById('comboText');
        const comboProgress = document.getElementById('comboProgress');
        const timerValue = document.getElementById('timerValue');
        const timerLabel = document.getElementById('timerLabel');
        const statusText = document.getElementById('statusText');
        const radioOptions = document.querySelectorAll('.radio-option');

        // Initialize audio context on user interaction
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Generate coach's whistle sound
        function playWhistle() {
            if (!audioContext) return;

            const duration = 0.6;
            const t = audioContext.currentTime;

            // Main whistle tone
            const osc1 = audioContext.createOscillator();
            const gain1 = audioContext.createGain();
            osc1.type = 'sine';
            osc1.frequency.setValueAtTime(3200, t);
            osc1.frequency.setValueAtTime(3400, t + 0.05);
            osc1.frequency.setValueAtTime(3200, t + duration);
            osc1.connect(gain1);
            gain1.connect(audioContext.destination);
            gain1.gain.setValueAtTime(0, t);
            gain1.gain.linearRampToValueAtTime(0.6, t + 0.02);
            gain1.gain.setValueAtTime(0.6, t + duration - 0.1);
            gain1.gain.linearRampToValueAtTime(0, t + duration);
            osc1.start(t);
            osc1.stop(t + duration);

            // Upper harmonic for brightness
            const osc2 = audioContext.createOscillator();
            const gain2 = audioContext.createGain();
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(6400, t);
            osc2.frequency.setValueAtTime(6800, t + 0.05);
            osc2.frequency.setValueAtTime(6400, t + duration);
            osc2.connect(gain2);
            gain2.connect(audioContext.destination);
            gain2.gain.setValueAtTime(0, t);
            gain2.gain.linearRampToValueAtTime(0.15, t + 0.02);
            gain2.gain.setValueAtTime(0.15, t + duration - 0.1);
            gain2.gain.linearRampToValueAtTime(0, t + duration);
            osc2.start(t);
            osc2.stop(t + duration);

            // Noise burst for attack
            const bufferSize = audioContext.sampleRate * 0.05;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const noise = audioContext.createBufferSource();
            noise.buffer = noiseBuffer;
            const noiseGain = audioContext.createGain();
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 3200;
            noiseFilter.Q.value = 2;
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioContext.destination);
            noiseGain.gain.setValueAtTime(0.3, t);
            noiseGain.gain.linearRampToValueAtTime(0, t + 0.05);
            noise.start(t);
        }

        // Get a male voice
        let maleVoice = null;
        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            // Prefer deeper male voices
            const preferredVoices = ['Daniel', 'Alex', 'Fred', 'Thomas', 'Gordon', 'Male'];
            for (const name of preferredVoices) {
                const found = voices.find(v => v.name.includes(name) && v.lang.startsWith('en'));
                if (found) {
                    maleVoice = found;
                    break;
                }
            }
            // Fallback to any English male voice
            if (!maleVoice) {
                maleVoice = voices.find(v => v.lang.startsWith('en') && v.name.toLowerCase().includes('male'));
            }
            // Final fallback to any English voice
            if (!maleVoice) {
                maleVoice = voices.find(v => v.lang.startsWith('en'));
            }
        }
        speechSynthesis.onvoiceschanged = loadVoices;
        loadVoices();

        // Text-to-speech with male voice
        function speak(text) {
            return new Promise((resolve) => {
                const utterance = new SpeechSynthesisUtterance(text);
                if (maleVoice) {
                    utterance.voice = maleVoice;
                }
                utterance.pitch = 0.85;
                utterance.rate = 1.0;
                utterance.onend = resolve;
                utterance.onerror = resolve;
                speechSynthesis.speak(utterance);
            });
        }

        // Generate all combinations with optimized order for rest breaks
        function generateCombinations(size) {
            // First generate all possible combos
            const allCombos = [];
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    if (i !== j) {
                        allCombos.push({ up: i, down: j });
                    }
                }
            }

            // Now reorder to maximize rest between rounds for each wrestler
            const ordered = [];
            const remaining = [...allCombos];
            const lastAppearance = new Map();

            for (let round = 0; round < allCombos.length; round++) {
                // Cycle through who should rest: size, 1, 2, 3, ..., size-1, size, 1, ...
                const idealResting = ((round + size - 1) % size) + 1;

                let bestIndex = -1;
                let bestScore = -Infinity;

                // Try to find a combo where the ideal resting wrestler doesn't participate
                for (let i = 0; i < remaining.length; i++) {
                    const combo = remaining[i];
                    if (combo.up !== idealResting && combo.down !== idealResting) {
                        // Among valid combos, prefer ones where both wrestlers are well-rested
                        const upRest = round - (lastAppearance.get(combo.up) ?? -1);
                        const downRest = round - (lastAppearance.get(combo.down) ?? -1);
                        const score = Math.min(upRest, downRest);

                        if (score > bestScore) {
                            bestScore = score;
                            bestIndex = i;
                        }
                    }
                }

                // Fallback if no combo excludes the ideal resting wrestler
                if (bestIndex === -1) {
                    for (let i = 0; i < remaining.length; i++) {
                        const combo = remaining[i];
                        const upRest = round - (lastAppearance.get(combo.up) ?? -1);
                        const downRest = round - (lastAppearance.get(combo.down) ?? -1);
                        const score = Math.min(upRest, downRest);

                        if (score > bestScore) {
                            bestScore = score;
                            bestIndex = i;
                        }
                    }
                }

                const chosen = remaining[bestIndex];
                ordered.push(chosen);
                remaining.splice(bestIndex, 1);
                lastAppearance.set(chosen.up, round);
                lastAppearance.set(chosen.down, round);
            }

            return ordered;
        }

        // Number words for speech
        const numberWords = ['', 'One', 'Two', 'Three', 'Four'];

        // Update UI
        function updateDisplay() {
            const combo = combinations[currentComboIndex];
            if (drillMode === 'takedowns') {
                comboText.textContent = `${combo.up} vs ${combo.down}`;
            } else {
                comboText.textContent = `${combo.up} up, ${combo.down} down`;
            }
            comboProgress.textContent = `Round ${currentComboIndex + 1} of ${combinations.length}`;
        }

        // Sleep helper
        function sleep(ms) {
            return new Promise(resolve => {
                currentTimer = setTimeout(resolve, ms);
            });
        }

        // Countdown with pause support
        async function countdown(seconds, label) {
            remainingTime = seconds;
            timerLabel.textContent = label;

            while (remainingTime > 0) {
                if (isPaused) {
                    await new Promise(resolve => {
                        const checkPause = setInterval(() => {
                            if (!isPaused) {
                                clearInterval(checkPause);
                                resolve();
                            }
                        }, 100);
                    });
                }

                timerValue.textContent = remainingTime;
                await sleep(1000);
                remainingTime--;
            }
            timerValue.textContent = '0';
        }

        // Run single combo
        async function runCombo() {
            const combo = combinations[currentComboIndex];
            updateDisplay();

            // Phase 1: Announce and setup
            currentPhase = 'setup';
            statusText.textContent = 'Get in position...';
            statusText.className = 'status-text status-setup';

            if (drillMode === 'takedowns') {
                await speak(`${numberWords[combo.up]} versus ${numberWords[combo.down]}`);
            } else {
                await speak(`${combo.up} up, ${combo.down} down`);
            }
            await countdown(setupTime, 'setup');

            // Phase 2: SET (1 second)
            currentPhase = 'set';
            if (drillMode === 'takedowns') {
                statusText.textContent = 'SET!';
                statusText.className = 'status-text status-set';
                await speak('Set!');
            } else {
                statusText.textContent = 'DOWN! SET!';
                statusText.className = 'status-text status-set';
                await speak('Down! Set!');
            }
            await countdown(1, 'ready');

            // Whistle to start
            playWhistle();

            // Phase 3: Wrestling
            currentPhase = 'wrestling';
            statusText.textContent = 'WRESTLE!';
            statusText.className = 'status-text status-wrestling';

            await countdown(roundDuration, 'wrestling');

            // Whistle to end
            playWhistle();
        }

        // Main drill loop
        async function runDrill() {
            combinations = generateCombinations(groupSize);
            currentComboIndex = 0;
            isPaused = false;

            setupScreen.style.display = 'none';
            drillScreen.style.display = 'block';

            while (currentComboIndex < combinations.length) {
                await runCombo();
                currentComboIndex++;

                if (currentComboIndex < combinations.length) {
                    await sleep(500); // Brief pause between combos
                }
            }

            // Done
            statusText.textContent = 'DRILL COMPLETE!';
            statusText.className = 'status-text status-done';
            timerValue.textContent = '‚úì';
            timerLabel.textContent = 'done';
            comboText.textContent = 'All rounds finished';
            comboProgress.textContent = `${combinations.length} rounds completed`;

            await speak('Drill complete!');
        }

        // Stop drill
        function stopDrill() {
            if (currentTimer) {
                clearTimeout(currentTimer);
            }
            speechSynthesis.cancel();
            isPaused = false;
            currentComboIndex = combinations.length; // End the loop

            drillScreen.style.display = 'none';
            menuScreen.style.display = 'block';
        }

        // Show setup screen for selected mode
        function selectMode(mode) {
            drillMode = mode;
            menuScreen.style.display = 'none';
            setupScreen.style.display = 'block';
            if (mode === 'takedowns') {
                setupTitle.textContent = 'ü§º Takedowns Drill';
            } else {
                setupTitle.textContent = 'ü§º Up/Down Drill';
            }
        }

        // Event Listeners
        takedownsBtn.addEventListener('click', () => selectMode('takedowns'));
        updownBtn.addEventListener('click', () => selectMode('updown'));

        backBtn.addEventListener('click', () => {
            setupScreen.style.display = 'none';
            menuScreen.style.display = 'block';
        });

        radioOptions.forEach(option => {
            option.addEventListener('click', () => {
                radioOptions.forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                option.querySelector('input').checked = true;
                groupSize = parseInt(option.dataset.value);
            });
        });

        setupSlider.addEventListener('input', () => {
            setupTime = parseInt(setupSlider.value);
            setupValue.textContent = `${setupTime} seconds`;
        });

        durationSlider.addEventListener('input', () => {
            roundDuration = parseInt(durationSlider.value);
            durationValue.textContent = `${roundDuration} seconds`;
        });

        startBtn.addEventListener('click', () => {
            initAudio();
            runDrill();
        });

        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';

            if (isPaused) {
                speechSynthesis.pause();
            } else {
                speechSynthesis.resume();
            }
        });

        stopBtn.addEventListener('click', stopDrill);
    </script>
</body>
</html>
